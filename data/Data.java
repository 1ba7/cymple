// This class essentially provides an interface to the cympledata.bin file
// while is generated by the generate program.
public class Data implements Visualisable {
	// A LinkedHashMap containing User objects for all the users, indexed
	// by their ids. LinkedHashMap is used instead of HashMap so that the
	// users can be returned in order. We can assume that insertion order ==
	// natural order because the format of cymple.bin guarantees it.
	private Map<Short, User> users;
	// A LinkedHashMap containing Artist objects for all the artists, indexed
	// by their ids. LinkedHashMap is used instead of HashMap so that the
	// artists can be returned in order. We can assume that insertion order ==
	// natural order because the format of cymple.bin guarantees it.
	private Map<Short, Artist> artists;
	// A LinkedHashMap containing Album objects for all the albums, indexed
	// by their ids. LinkedHashMap is used instead of HashMap so that the
	// albums can be returned in order. We can assume that insertion order ==
	// natural order because the format of cymple.bin guarantees it.
	private Map<Short, Album> albums;
	// A LinkedHashMap containing Track objects for all the tracks, indexed
	// by their ids. LinkedHashMap is used instead of HashMap so that the
	// tracks can be returned in order. We can assume that insertion order ==
	// natural order because the format of cymple.bin guarantees it.
	private Map<Short, Track> tracks;
	// The open cympledata.bin from which data is read.
	private RandomAccessFile file;
	// The users to which the current query applies (represented as shorts,
	// see User).
	private short[] users;
	// The albums to which the current query applies (represented as shorts,
	// see Album).
	private short[] albums;
	// An sorted array of shorts, each of which represent a time
	// (see common/Time).
	private short[] listens;

	// Constructor. Takes the path to "cymple.bin" as its argument and reads in
	// the necessary data from those files.
	public Data(String filename) {
	}

	// Returns the length of listens.
	public int size() {
	}

	// Returns the number of users.
	public int usersSize() {
	}

	// Returns the number of artists.
	public int artistsSize() {
	}

	// Returns the number of albums.
	public int albumsSize() {
	}

	// Returns the number of tracks.
	public int tracksSize() {
	}

	// Returns an array of all users.
	public User[] getUsers() {
	}

	// Returns an array of all artists.
	public Artist[] getArtists() {
	}

	// Returns an array containing the albums by the given artists. This is
	// likely going to be called with data from a SelectItem, so it takes
	// an array of SelectItemData which is cast into an array of Artists.
	public Album[] getAlbumsByArtists(SelectItemData[] artists) {
	}

	// Returns an array containing the tracks from the given albums. This is
	// likely going to be called with data from a SelectItem, so it takes
	// an array of SelectItemData which is cast into an array of Artists.
	public Track[] getTracksFromAlbums(SelectItemData[] albums) {
	}

	// Returns the user with this id.
	public User getUser(short id) {
	}

	// Returns the artist with this id.
	public Artist getArtist(short id) {
	}

	// Returns the album with this id.
	public Album getAlbum(short id) {
	}

	// Returns the track with this id.
	public Track getTrack(short id) {
	}

	// Updates the values of users, albums and ultimately listens. This will
	// change the behaviour of the Visualisable functions. This is likely
	// going to be called with data from a SelectItem, so it takes arrays of
	// SelectItemData which are cast into arrays of Users and Albums.
	public void query(SelectItemData[] users, SelectItemData[] albums) {
	}

	// This returns the number of listens between the given Times. This can be
	// implemented using a binary search.
	public int between(Time start, Time finish) {
	}

	// Returns the earliest Time in the data.
	public Time minTime() {
	}

	// Returns the latest Time in the data.
	public Time maxTime() {
	}

	// This is the data that is used to draw the chart, sorted by value.
	// See common/ChartKey.
	public TreeMap<String, Integer> chartData(Time start, Time finish, ChartKey key) {
	}

}
