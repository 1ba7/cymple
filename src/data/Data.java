package cymple.data;
import cymple.common.*;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;

class InvalidFileFormatException extends RuntimeException {
	public InvalidFileFormatException() {
		super("This is not a valid cymple.bin file.");
	}

	public InvalidFileFormatException(Throwable cause) {
		super("This is not a valid cymple.bin file.", cause);
	}
}

// This class essentially provides an interface to the cympledata.bin file
// while is generated by the generate program.
public class Data implements Graphable, Chartable, StatusSource {
	// The open cympledata.bin from which data is read.
	private RandomAccessFile file;

	// The size of the header block of cymple.bin.
	private int headerSize;

	// The earliest time (i.e., the time represented by -32768).
	private long minTime;
	// The latest time (i.e., the time represented by 32767).
	private long maxTime;

	// The number of users in the dataset.
	private int userCount;
	// The number of artists in the dataset.
	private int artistCount;
	// The number of albums in the dataset.
	private int albumCount;
	// The number of tracks in the dataset.
	private int trackCount;

	// The positions of the listens in cymple.bin for each user.
	private int[] userIndex;
	// The positions of the listens in cymple.bin for each user-artist tuple.
	private int[] artistIndex;
	// The positions of the listens in cymple.bin for each user-album tuple.
	private int[] albumIndex;
	// The positions of the listens in cymple.bin for each user-track tuple.
	private int[] trackIndex;

	// An array of User objects for all the users, indexed by their ids. The
	// format of cymple.bin guarantees that these are also in natural order.
	private User[] users;
	// An array of Artist objects for all the users, indexed by their ids. The
	// format of cymple.bin guarantees that these are also in natural order.
	private Artist[] artists;
	// An array of Album objects for all the users, indexed by their ids. The
	// format of cymple.bin guarantees that these are also in natural order.
	private Album[] albums;
	// An array of Track objects for all the users, indexed by their ids. The
	// format of cymple.bin guarantees that these are also in natural order.
	private Track[] tracks;

	// The users to which the current query applies.
	private User[] queryUsers;
	// The albums to which the current query applies.
	private Album[] queryAlbums;
	// An sorted array of shorts, each of which represent a time.
	private short[] listens;

    // Sets the position at which the graph is drawn.
	private double position;
    // Sets the fraction of the total dataset to be displayed.
	private double resolution;

	// The key which charts are displayed with.
	private ChartKey key;
	// The number of samples in a graphData
	private int sampleRate;
	// The maximum number of listens at this resolution
	private int maximum;
	private int currentListens;

	// The ChartData object for this data. This is "cached", but is regenerated
	// every time update() is called.
	private ChartData chartData;
	// The GraphData object for this data. This is "cached", but is regenerated
	// every time update() is called.
	private GraphData graphData;

	// Status string to be shown in the statusbar.
	private String status;
	// How much the statusbar should show as displayed
	private double complete;

	// Constructor. Takes the path to "cymple.bin" as its argument and reads in
	// the necessary data from those files.
	public Data(String filename) {
		try {
			file = new RandomAccessFile(filename, "r");
			if (file.readInt() != 0x20080427) {
				throw new InvalidFileFormatException();
			}
			
			headerSize = file.readInt();
			minTime = file.readLong();
			maxTime = file.readLong();

			userCount = file.readUnsignedShort();
			artistCount = file.readUnsignedShort();
			albumCount = file.readUnsignedShort();
			trackCount = file.readUnsignedShort();

			userIndex = new int[userCount + 1];
			artistIndex = new int[userCount * artistCount + 1];
			albumIndex = new int[userCount * albumCount + 1];
			trackIndex = new int[userCount * trackCount + 1];

			byte[] bytes;
			file.seek(headerSize);

			bytes = new byte[userCount * 4];
			file.readFully(bytes);
			for (int i = 0; i < bytes.length / 4; i++) {
				userIndex[i] = bytesToInt(bytes, i);
			}

			bytes = new byte[userCount * artistCount * 4];
			file.readFully(bytes);
			for (int i = 0; i < bytes.length / 4; i++) {
				artistIndex[i] = bytesToInt(bytes, i);
			}

			bytes = new byte[userCount * albumCount * 4];
			file.readFully(bytes);
			for (int i = 0; i < bytes.length / 4; i++) {
				albumIndex[i] = bytesToInt(bytes, i);
			}

			bytes = new byte[userCount * trackCount * 4];
			file.readFully(bytes);
			for (int i = 0; i < bytes.length / 4; i++) {
				trackIndex[i] = bytesToInt(bytes, i);
			}

			userIndex[userCount] = artistIndex[0];
			artistIndex[userCount * artistCount] = albumIndex[0];
			albumIndex[userCount * albumCount] = trackIndex[0];
			trackIndex[userCount * trackCount] = (int)file.length();

			setUsers();
			setArtists();
			setStatus("Welcome to Cymple.");
			setComplete(0);
			query(users, albums);
			setPosition(0.0);
			setResolution(1.0);
			setChartKey(ChartKey.Artist);
			setSampleRate(25);
		}
		catch (IOException e) {
			throw new InvalidFileFormatException(e);
		}
	}

	// Returns the length of listens.
	public int size() {
		return listens.length;
	}

	// Returns the number of users.
	public int userCount() {
		return userCount;
	}

	// Returns the number of artists.
	public int artistCount() {
		return artistCount;
	}

	// Returns the number of albums.
	public int albumCount() {
		return albumCount;
	}

	// Returns the number of tracks.
	public int trackCount() {
		return trackCount;
	}

	// Returns an array of all users.
	public User[] getUsers() {
		return users;
	}

	// Returns an array of all artists.
	public Artist[] getArtists() {
		return artists;
	}

	// Returns an array containing the albums by the given artists. This is
	// likely going to be called with data from a SelectItem, so it takes
	// an array of SelectItemData which is cast into an array of Artists.
	public Album[] getAlbumsByArtists(SelectItemData[] artists) {
		Album[] result;
		int size = 0, i;

		for (i = 0; i < artists.length; i++) {
			size += ((Artist)artists[i]).albumCount();
		}
		result = new Album[size];

		Album[] albums;
		size = 0;
		for (i = 0; i < artists.length; i++) {
			albums = ((Artist)artists[i]).getAlbums();
			for (int j = 0; j < albums.length; j++) {
				result[size] = albums[j];
				size++;
			}
		}

		return result;
	}

	// Returns an array containing the artists associated with the given albums.
	public Artist[] getArtistsByAlbums(SelectItemData[] albums) {
		Artist[] result;
		Artist lastArtist = null;
		int size = 0,  i;

		for (i = 0; i < albums.length; i++) {
			if (((Album)albums[i]).getArtist() != lastArtist) {
				lastArtist = ((Album)albums[i]).getArtist();
				size++;
			}
		}

		result = new Artist[size];
		size = 0;
		for (i = 0; i < albums.length; i++) {
			if (((Album)albums[i]).getArtist() != lastArtist) {
				lastArtist = ((Album)albums[i]).getArtist();
				result[size] = lastArtist;
				size++;
			}
		}

		return result;
	}

	// Returns an array containing the tracks from the given albums. This is
	// likely going to be called with data from a SelectItem, so it takes
	// an array of SelectItemData which is cast into an array of Artists.
	public Track[] getTracksFromAlbums(SelectItemData[] albums) {
		Track[] result;
		int size = 0, i;

		for (i = 0; i < albums.length; i++) {
			size += ((Album)albums[i]).trackCount();
		}
		result = new Track[size];

		Track[] tracks;
		size = 0;
		for (i = 0; i < albums.length; i++) {
			tracks = ((Album)albums[i]).getTracks();
			for (int j = 0; j < tracks.length; j++) {
				result[size] = tracks[j];
				size++;
			}
		}

		return result;
	}

	// Updates the values of users, albums and ultimately listens. This will
	// change the output of the Chartable, Graphable methods. This is likely
	// going to be called with data from a SelectItem, so it takes arrays of
	// SelectItemData which are cast into arrays of Users and Albums.
	public void query(SelectItemData[] users, SelectItemData[] albums) {
		try {
			byte[] bytes;
			int index;
			int size;

			size = 0;

			for (int i = 0; i < users.length; i++) {
				for (int j = 0; j < albums.length; j++) {
					index = users[i].id() * albumCount + albums[j].id();
					size += (albumIndex[index + 1] - albumIndex[index]) / 2;
				}
			}

			listens = new short[size];
			size = 0;
			setStatus("Reading data from cymple.bin...");
			setComplete(0);
			for (int i = 0; i < users.length; i++) {
				for (int j = 0; j < albums.length; j++) {
					index = users[i].id() * albumCount + albums[j].id();
					bytes = new byte[albumIndex[index + 1] - albumIndex[index]];
					file.readFully(bytes);
					for (int k = 0; k < bytes.length / 2; k++) {
						listens[size] = bytesToShort(bytes, k);
						size++;
						setComplete(getComplete() + ((double)size) / listens.length);
					}
				}
			}
			setStatus("Sorting data...");
			setComplete(0);
			Arrays.sort(listens);
			setComplete(1);

			this.queryUsers = (User[])users;
			this.queryAlbums = (Album[])albums;
		}
		catch (IOException e) {
			throw new InvalidFileFormatException(e);
		}
	}

	// This means that the graph will show a fraction of the total dataset.
	public void setResolution(double resolution) {
		this.resolution = resolution;
	}

	// Sets the position at which the graph is drawn.
	public void setPosition(double position) {
		this.position = position;
	}

	// Updates the chartData and graphData attributes, if necessary.
	public void update() {
		try {
			// Check if maximum needs to be updated and update if so
			if (graphData == null || graphData.getResolution() != resolution) {
				setStatus("Recalcuating maximum point...");
				setComplete(0);
				maximum = 0;
				short start, finish;
				int possibleMaximum;
				for (int i = 0; i < sampleRate / resolution; i++) {
					start = (short)((((resolution / sampleRate) * i) - 0.5) * 0xFFFF);
					finish = (short)((((resolution / sampleRate) * (i + 1)) - 0.5) * 0xFFFF);

					possibleMaximum = binarySearch(listens, finish) - binarySearch(listens, start);
					if (possibleMaximum > maximum) {
						maximum = possibleMaximum;
					}
					setComplete(getComplete() + i * resolution / sampleRate);
				}
			}

	        // Check if chartData needs to be updated and update if so
			if (chartData == null || chartData.getResolution() != resolution ||
				chartData.getPosition() != position ||
				chartData.getChartKey() != key) {
				SelectItemData[] data;
				byte[] bytes;
				short[] listens;
				int[] index;
				String[] names;
				int[] absolutes;
				int id, count;

				if (key == ChartKey.User) {
					data = queryUsers;
					index = userIndex;
					count = userCount;
				}
				else if (key == ChartKey.Artist) {
					data = getArtistsByAlbums(queryAlbums);
					index = artistIndex;
					count = artistCount;
				}
				else if (key == ChartKey.Album) {
					data = queryAlbums;
					index = albumIndex;
					count = albumCount;
				}
				else {
					data = getTracksFromAlbums(albums);
					index = trackIndex;
					count = trackCount;
				}

				setStatus("Recalculating charts...");
				setComplete(0);

				names = new String[data.length];
				absolutes = new int[data.length];
				int jMax = index == userIndex ? 1 : users.length;
				for (int j = 0; j < jMax; j++) {
					for (int i = 0; i < data.length; i++) {
						id = j * count + data[i].id();
						bytes = new byte[index[id + 1] - index[id]];
						file.seek(index[id]);
						file.readFully(bytes);
						listens = bytesToShorts(bytes);

						names[i] = data[i].toString();
						absolutes[i] += binarySearch(listens, finishShort()) - binarySearch(listens, startShort());
						setComplete(((double)(i * j + i)) / jMax * data.length);
					}
				}

				this.chartData = new ChartData(position, resolution, key, names, absolutes);
			}

	        // Check if graphData needs to be updated and update if so
			if (graphData == null || graphData.getResolution() != resolution ||
				graphData.getPosition() != position ||
				graphData.getSampleRate() != sampleRate) {
				double[] samples = new double[sampleRate];
				short start, finish;

				setStatus("Recalculating graph...");
				setComplete(0);
				currentListens = 0;
				for (int i = 0; i < sampleRate; i++) {
					start = (short)(((position * (1 - resolution) + resolution * i / sampleRate) - 0.5) * 0xFFFF);
					finish = (short)(((position * (1 - resolution) + resolution * (i + 1) / sampleRate) - 0.5) * 0xFFFF);
					samples[i] = (double)(binarySearch(listens, finish) - binarySearch(listens, start)) / maximum;
					currentListens += Math.round(samples[i] * maximum);
					setComplete((double)i / sampleRate);
				}

				this.graphData = new GraphData(position, resolution, samples, maximum);
			}

			setStatus("Visualising " + currentListens + " listens from " +
				queryUsers.length + " users  to " + queryAlbums.length + 
				" albums from " + start() + " to " + finish());
			setComplete(1);
		}
		catch (IOException e) {
			throw new InvalidFileFormatException(e);
		}
	}

	// Returns a String representation of the start time of the range, whose
	// format depends on the resolution.
	public String start() {
		Date date = new Date(shortToTime(startShort()));
		return timeToString(date);
	}

	// Returns a String representation of the end time of the range, whose
	// format depends on the resolution.
	public String finish() {
		Date date = new Date(shortToTime(finishShort()));
		return timeToString(date);
	}

	// Sets the number of samples taken to a GraphData.
	public void setSampleRate(int samples) {
		this.sampleRate = samples;
	}

	// Returns a GraphData object for the current dataset.
	public GraphData getGraphData() {
		return graphData;
	}

	// Sets the ChartKey for which the charts are calculated.
	public void setChartKey(ChartKey key) {
		this.key = key;
	}
	public ChartKey getChartKey() {
		return key;
	}

	// Returns a ChartData object for the current dataset.
	public ChartData getChartData() {
		return chartData;
	}

	// Returns a String displayable as a status in a Statusbar
	public String getStatus() {
		return status;
	}

	// Returns how much the statusbar should show as completed.
	public double getComplete() {
		return complete;
	}

	private void setStatus(String status) {
		this.status = status;
	}

	private void setComplete(double complete) {
		this.complete = complete;
	}

	private void setUsers() throws IOException {
		String name;
		int index;
		byte[] bytes;

		file.seek(32);
		bytes = new byte[file.readInt()];
		file.readFully(bytes);
		index = 2;
		users = new User[userCount];

		for (int i = 0; i < userCount; i++) {
			name = readString(bytes, index);
			users[i] = new User(name, i);
			index += 1 + name.length();
		}
	}

	private void setArtists() throws IOException {
		String name;
		Album[] albums;
		Track[] tracks;
		int index;
		int trackId = 0, albumId = 0;
		byte[] bytes;

		bytes = new byte[file.readInt()];
		file.readFully(bytes);
		index = 2;
		artists = new Artist[artistCount];
		this.albums = new Album[albumCount];
		this.tracks = new Track[trackCount];

		for (int i = 0; i < artistCount; i++) {
			name = readString(bytes, index);
			index += 1 + name.length();
			albums = new Album[readShort(bytes, index)];
			index += 2;

			artists[i] = new Artist(name, i, albums);
			for (int j = 0; j < albums.length; j++, albumId++) {
				name = readString(bytes, index);
				index += 1 + name.length();
				tracks = new Track[readShort(bytes, index)];
				index += 2;

				albums[j] = new Album(name, albumId, artists[i], tracks);
				this.albums[albumId] = albums[j];
				for (int k = 0; k < tracks.length; k++, trackId++) {
					name = readString(bytes, index);
					index += 1 + name.length();
					tracks[k] = new Track(name, trackId, albums[j]);
					this.tracks[trackId] = tracks[k];
				}
			}
		}
		this.albums = getAlbumsByArtists(artists);
		this.tracks = getTracksFromAlbums(this.albums);
	}

	private int bytesToInt(byte[] bytes, int i) {
		return ((bytes[i * 4] & 255) << 24) + ((bytes[i * 4 + 1] & 255) << 16) +
			((bytes[i * 4 + 2] & 255) << 8) + (bytes[i * 4 + 3] & 255);
	}

	private short bytesToShort(byte[] bytes, int i) {
		return (short)(((bytes[i * 2] & 255) << 8) + (bytes[i * 2 + 1] & 255));
	}

	private short readShort(byte[] bytes, int i) {
		return (short)(((bytes[i] & 255) << 8) + (bytes[i + 1] & 255));
	}

	private short[] bytesToShorts(byte[] bytes) {
		short[] result = new short[bytes.length / 2];
		for (int i = 0; i < result.length; i++) {
			result[i] = bytesToShort(bytes, i);
		}
		return result;
	}

	private long shortToTime(short listen) {
		return (long)(minTime + (maxTime - minTime) * (0.5 + listen / 65535.0));
	}

	private short startShort() {
		return (short)(((position * (1 - resolution)) - 0.5) * 0xFFFF);
	}

	private short finishShort() {
		return (short)(((position * (1 - resolution) + resolution) - 0.5) * 0xFFFF);
	}

	private long timeDiff() {
		return shortToTime(finishShort()) - shortToTime(startShort());
	}

	private String timeToString(Date date) {
		if (timeDiff() < 86400000L) {
			return (new SimpleDateFormat("MMMM dd, kk:mm, yyyy")).format(date);
		}
		else if (timeDiff() < 15552000000L) {
			return (new SimpleDateFormat("MMMM dd, yyyy")).format(date);
		}
		else {
			return (new SimpleDateFormat("MMMM yyyy")).format(date);
		}
	}

	private String readString(byte[] bytes, int index) {
		try {
			int length = bytes[index] & 255;
			return new String(bytes, index + 1, length, "UTF8");
		}
		catch (java.io.UnsupportedEncodingException e) {
			throw new InvalidFileFormatException(e);
		}
	}

	private int binarySearch(short[] listens, short time) {
		int n = Arrays.binarySearch(listens, time);
		return n > 0 ? n : ~n;
	}
}
